# Medicare Chatbot POC - Intent Recognition & Slot Filling Project Plan

**Document Version:** 1.1
**Date:** 2025-06-13

## 1. Project Overview

### 1.1. Purpose

This POC aims to demonstrate the feasibility of using AWS Bedrock (Claude 3 Haiku) for intent recognition and slot filling in a Medicare chatbot context. The project will focus on accurately identifying user intents and extracting relevant information from their queries.

> **Important**: This is a standalone POC that will be migrated into the main Medicare codebase once the initial phase is complete. The goal is to validate the approach, patterns, and integration with AWS services before moving the functionality into the production environment.

### 1.2. Key Components

---

## 2. Project Goals & Objectives

### 2.1. Business Goals (Long-term Vision - Context for POC)

- **Enhance Self-Service:** Enable Medicare beneficiaries to independently access information about their plans, coverage, entitlements, and drug prices.
- **Improve Accessibility:** Provide information in plain conversational language, reducing the need to navigate complex UIs or large documents.
- **Reduce Call Center Volume:** Decrease inbound call volume related to common Medicare inquiries.

### 2.2. POC Specific Objectives

- **Prove Core AI Capabilities:**
  - **Validate Intent & Slot Accuracy:** Achieve near **100% accuracy** in identifying user intent and extracting relevant slots for a predefined set of initial intents.
  - **Demonstrate Data Grounding:** Prove the ability to generate responses solely based on data retrieved from backend APIs (mocked for POC), **eliminating hallucination (zero tolerance)**.
  - **Test Conversational Flow & Naturalness:** Showcase the system's ability to:
    - Identify missing slots and proactively ask follow-up questions to gather necessary information.
    - Gracefully handle incomplete or ambiguous user inputs.
    - **Proactively redirect users** to appropriate questions or inform them when queries are outside the chatbot's current capabilities.
    - Produce responses that feel natural and empathetic, even when asking for clarification or redirecting.
  - **Maintain Content Safety & Appropriateness:** Ensure **no profane, objectionable, or harmful language** is ever generated by the chatbot.
- **Evaluate Bedrock Models:** Assess **Anthropic Claude 3 Haiku's** performance in terms of response accuracy, conversational flow, cost-effectiveness, and latency. Compare with AWS Lex for intent mapping.
- **Explore Prompt Engineering:** Gain hands-on experience and iterate on effective prompt engineering techniques for structured output (JSON) and natural conversation.
- **Understand AWS API Integration:** Learn how to interact with Bedrock, Comprehend Medical, and Lex APIs directly within application code.

---

## 3. Current Implementation Status

### 3.1. Completed Features

- **Local User Interface:** Chat UI built with Svelte 5 using runes (`$state()`, `$derived()`, `$effect()`, `$props()`)
- **Local Backend API:** Svelte 5 backend API for orchestrating interactions
- **Intent Recognition & Slot Filling:**
  - AWS Bedrock (Claude 3 Haiku) integration for NLU
  - AWS Comprehend Medical integration for drug entity extraction
  - AWS Lex integration available for testing alternative intent mapping
- **Backend Data Simulation:**
  - Mocked beneficiary data with realistic personas
  - Stubbed MCT service for future drug pricing integration
- **Context Management:**
  - In-memory session storage
  - Conversation history tracking
  - Slot backfilling from beneficiary data
- **Response Generation:**
  - Structured JSON responses with text and cards
  - Natural language follow-up questions
  - Out-of-scope redirection
  - Content safety filters

### 3.2. In Progress

- **MCT Service Integration:**
  - Currently stubbed with random pricing
  - Planned integration with real MCT API to pull drug data
- **Lex Intent Mapping:**
  - Basic integration complete
  - Testing and comparison with Bedrock
- **Stubbed Intents:**
  - Get more intent coverage built out, rather than placeholder data

### 3.3. Next Steps

1. **MCT Integration:**

   - Replace stubbed pricing with real MCT API calls
   - Add error handling and fallback logic
   - Implement caching for frequently requested drugs

2. **BEDAP Integration:**

   - Create stubbed BEDAP service for beneficiary data
   - Implement real BEDAP API integration
   - Add caching layer for beneficiary data
   - Handle error cases and fallbacks

3. **Intent Expansion:**

   - Add more intents, pending final list from CMS
   - Cover all possible cases and have real data

4. **Lex Testing:**

   - Compare intent recognition accuracy with Bedrock
   - Document findings and recommendations
   - Determine if Lex should be primary or fallback

5. **Infrastructure & Performance:**

   - **Secrets Management:**
     - Integrate AWS Secrets Manager
     - Move API keys and credentials to Secrets Manager
     - Implement secret rotation and versioning
     - Add local development secret handling
   - **Session Storage:**
     - Implement global session storage with ElastiCache
     - Add session expiration and cleanup
     - Handle session migration and failover
   - **Query Caching:**
     - Add caching layer for API responses
     - Cache Bedrock, Comprehend Medical, and Lex results
     - Implement cache invalidation strategies
   - **Logging & Monitoring:**
     - Set up Kinesis Data Streams for logging
     - Add structured logging for all API calls
     - Implement log aggregation and analysis
   - **Feature Flagging:**
     - Add feature flag system for toggling services
     - Support switching between Lex and Bedrock
     - Enable A/B testing of different configurations
     - Allow gradual rollout of new features
   - **Data Storage (Future Consideration):**
     - Evaluate moving intents to DynamoDB
     - Consider storing canned responses in DynamoDB
     - Explore options for prompt storage and versioning
     - Assess need for persistent storage of other data

6. **Testing & Documentation:**
   - Expand test coverage
   - Document API integration patterns
   - Create integration guides

---

## 4. Key Initial Intents & Slots (Examples for POC)

The POC will focus on a subset of the following (2-5 total):

- **`GetDrugPrice`**:
  - `drugName` (string, required, normalized via Comprehend Medical)
  - `dosage` (string, required, normalized via Comprehend Medical)
  - `drugForm` (string, optional, normalized via Comprehend Medical)
  - `frequency` (string, optional)
  - `duration` (string, optional)
- **`Welcome`**:
  - (No specific slots; simple pleasantries)
- **`Unknown`**:
  - (System intent when user query does not match)
- More to come

---

## 5. Technical Architecture (POC Level - Local & Self-Contained)

This POC will be implemented as a **single, self-contained application** running locally, built with Svelte 5.

### 5.1. Core Components

- **Svelte 5 Application:**
  - **Role:** Provides a simple web-based user interface for chat interaction. Acts as the local backend API for handling requests from the UI.
  - **Responsibilities:**
    - Manages **in-memory conversation context** (user input history, identified intent, extracted slots for the current session).
    - Contains mocked data and logic for backend API responses.
    - Orchestrates direct API calls to AWS Bedrock and AWS Comprehend Medical using the AWS SDK (Boto3 for Python calls if the Svelte backend makes Python subprocess calls, or AWS SDK for JavaScript/TypeScript if directly in JS/TS).
    - Receives user input from the UI and sends responses back.
- **AWS Bedrock (Anthropic Claude 3 Haiku as primary, others for evaluation):**
  - **Role:** The core Large Language Model (LLM) for natural language understanding and generation.
  - **Integration:** Accessed directly via API calls (e.g., Boto3 `bedrock-runtime` client in Python or AWS SDK for JS `BedrockRuntimeClient`) from the Svelte application's backend logic.
  - **Responsibilities:**
    - **Intent Recognition and Slot Filling:** Based on user input and a detailed system prompt, outputs a JSON object with `intent` and `slots`.
    - **Grounded Response Generation:** Given extracted data from mocked APIs, crafts human-readable responses.
    - **Follow-up Question Generation:** Formulates natural questions for missing required slots.
    - **Out-of-Scope Redirection:** Generates polite messages for unanswerable queries.
    - **Content Safety:** Adheres to safety instructions within prompts (no objectionable language).
- **AWS Comprehend Medical:**
  - **Role:** Specialized Named Entity Recognition (NER) for medical terminology.
  - **Integration:** Accessed directly via API calls (e.g., Boto3 `comprehendmedical` client in Python or AWS SDK for JS `ComprehendMedicalClient`) from the Svelte application's backend logic.
  - **Responsibilities:**
    - Extracts and normalizes entities like `drugName`, `dosage`, `drugForm` from user input (e.g., mapping to RxNorm concepts).

### 5.2. Data Flow (Local, In-Memory)

1. **User Input:** User types a message into the Svelte UI.
2. **Svelte UI:** Sends the user input to the local Svelte backend API (e.g., via a `fetch` call to `/api/chat`).
3. **Svelte Backend (Local API):**
   - Receives user input and a unique `sessionId` (can be a simple timestamp on first call, maintained by UI).
   - Retrieves the current `conversationContext` for that `sessionId` from its in-memory store.
   - **Phase 1: Intent & Slot Extraction:**
     - Constructs a detailed Bedrock prompt (including the user input and the current `conversationContext`).
     - The Bedrock prompt should include a `SYSTEM` role message that explicitly defines expected JSON output for intent and slots, possible intents, and current date context for relative date parsing (e.g., "Current Date: 2025-06-05").
     - Use `temperature=0.0`, `top_k=1`, and `stop_sequences=["```"]` with a JSON prefill (`"```json\n"`) to enforce JSON output.
     - Calls AWS Bedrock (Claude 3 Haiku) for `intent` and `slots` extraction.
     - If `drugName`, `dosage`, `drugForm` are present or suspected, calls AWS Comprehend Medical to normalize these terms (e.g., `detect_entities_v2`).
     - Consolidates extracted slots:
       - User-provided slots.
       - Normalized slots from Comprehend Medical.
       - Slots "backfilled" from _mocked_ beneficiary data (e.g., `beneficiaryId` from JWT which is _mocked as known_ for POC).
   - **Phase 2: Response Formulation:**
     - Determines if all **required slots** for the identified `intent` are present:
       - If **missing slots**:
         - Constructs a Bedrock prompt with the `intent` and `missingSlots` to generate a polite follow-up question.
       - If **all slots present**:
         - Calls _mocked_ backend API functions (e.g., `mockGetDrugPrice`, `mockGetPreventiveServices`) to retrieve relevant data.
         - Based on `intent` and the retrieved _mocked_ data, determines response type:
           - **Canned Response:** If applicable, retrieves a pre-defined response from an in-code map.
           - **Grounded Generative Response:** If not canned, constructs a Bedrock prompt, feeding the retrieved _mocked_ data explicitly to Bedrock (e.g., in a JSON block or `<data>` tags) to craft a human-readable response. This prompt must include instructions for Bedrock to create structured "Cards" if applicable.
       - If **`intent` is "Unknown" or outside scope**:
         - Constructs a Bedrock prompt to generate a polite redirection message or inform the user of current limitations.
   - Updates the in-memory `conversationContext` with the latest user input, bot response, identified `intent`, and `slots`.
4. **Svelte Backend:** Returns the structured JSON response (containing text and optionally cards) to the Svelte UI.
5. **Svelte UI:** Displays the chatbot's response to the user.

---

## 6. Success Metrics for POC

- **Intent Recognition Accuracy:** Achieve >95% accuracy for the defined POC intents on a test dataset (to be evaluated by human review).
- **Slot Filling Accuracy:** Achieve >90% accuracy for extracting and normalizing required slots (to be evaluated by human review).
- **Response Latency:** Observe and document typical response times from Bedrock/Comprehend API calls (target < 5 seconds for total end-to-end local process, including network latency to AWS).
- **JSON Output Reliability:** >99% of Bedrock calls for intent/slot extraction and response generation produce valid, parseable JSON.
- **Hallucination Rate:** **0% hallucination** (zero tolerance, verified through rigorous testing and strict grounding with mocked data).
- **Content Safety:** **0% generation of profane, objectionable, or harmful language** (verified through testing and prompt engineering).
- **Conversation Naturalness & Redirection Effectiveness:** Qualitative assessment (manual review of sample conversations) of how well the bot handles incomplete information, asks follow-up questions, and redirects out-of-scope queries in a natural-feeling way.
- **Prompt Engineering Effectiveness:** Document successful prompt patterns for various scenarios and models.
- **Model Suitability:** Document findings on Claude 3 Haiku's performance.

---

## 7. Development Approach & Tools

- **Iterative Development:** Agile approach, focusing on rapid iteration and feedback.
- **AI Code Agents:** Utilize tools like WindSurf or Cursor to accelerate development. This documentation is the primary input.
- **Programming Language:** JavaScript/TypeScript (primary for Svelte backend) and Python (for direct AWS SDK interaction if preferred for Bedrock/Comprehend calls, or a separate test harness).
- **UI Framework:** Svelte 5.
- **Source Control:** Git (will be managed in a central repository).
- **Code Quality:** Emphasis on clear, modular code.
- **Intent Controller Pattern:** Implementation uses a class-based controller architecture with a router, where each controller handles the logic for a specific intent. This pattern allows for easy extension of new intents and associated logic.

---

## 8. Next Steps & Future Considerations (Beyond POC)

- **Expand Intent Coverage:** Gradually add more intents and associated slots.
- **Transition to AWS Infrastructure:** Move from local/in-memory components to AWS services (API Gateway, Lambda, DynamoDB, ElastiCache) for scalability and persistence.
- **Live Backend Integration:** Transition from mocked APIs to actual backend REST APIs.
- **Scalability & Observability:** Implement production-ready architecture, logging, monitoring, and alerting.
- **Advanced Context:** Explore techniques for longer-term context memory.
- **User Feedback Loop:** Integrate mechanisms for collecting user feedback to continuously improve chatbot performance.
- **Voice Integration:** Potential for voice input/output in future iterations.

---
